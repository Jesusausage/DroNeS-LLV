using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.EventSystems;using UnityEngine.UI;public class Teleport : MonoBehaviour, IPointerClickHandler {    public Camera miniMapCam;    public GameObject mainCamContainer;    public GameObject boundary;    private MeshCollider boundaryCollider;    // Update is called once per frame    private void Awake() {        if (miniMapCam == null) {            miniMapCam = GameObject.Find("Minimap Camera").GetComponent<Camera>();        }        if (mainCamContainer == null) {            mainCamContainer = GameObject.Find("RTSCamera");        }        if (boundary == null) {            boundary = GameObject.Find("Boundary").transform.GetChild(0).gameObject;        }        boundaryCollider = boundary.GetComponent<MeshCollider>();    }    public void OnPointerClick(PointerEventData eventData) {        Vector2 localCursor = new Vector2(0, 0);        if (RectTransformUtility.ScreenPointToLocalPointInRectangle(GetComponent<RawImage>().rectTransform, eventData.pressPosition, eventData.pressEventCamera, out localCursor)) {            Texture tex = GetComponent<RawImage>().texture;            Rect r = GetComponent<RawImage>().rectTransform.rect;            //Using the size of the texture and the local cursor, clamp the X,Y coords between 0 and width - height of texture            float coordX = Mathf.Clamp(0, (((localCursor.x - r.x) * tex.width) / r.width), tex.width);            float coordY = Mathf.Clamp(0, (((localCursor.y - r.y) * tex.height) / r.height), tex.height);            //Convert coordX and coordY to % (0.0-1.0) with respect to texture width and height            float recalcX = coordX / tex.width;            float recalcY = coordY / tex.height;            localCursor = new Vector2(recalcX, recalcY);            CastMiniMapRayToWorld(localCursor);        }    }    private void CastMiniMapRayToWorld(Vector2 localCursor) {        float horizontalScale = miniMapCam.pixelWidth * GetComponent<RawImage>().uvRect.width;        float xDir = localCursor.x * horizontalScale + GetComponent<RawImage>().uvRect.x * miniMapCam.pixelWidth;        float verticalScale = miniMapCam.pixelHeight * GetComponent<RawImage>().uvRect.height;        float yDir = localCursor.y * verticalScale + GetComponent<RawImage>().uvRect.y * miniMapCam.pixelHeight;        Vector2 targetCoordinates = new Vector2(xDir, yDir);        Ray miniMapRay = miniMapCam.ScreenPointToRay(targetCoordinates);        if (boundaryCollider.Raycast(miniMapRay, out RaycastHit miniMapHit, 3000)) {            Vector3 target = miniMapHit.point;            target.y = mainCamContainer.GetComponent<RTSCamera>().ceiling;            mainCamContainer.transform.position = target;        }    }}